<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>EasyDelegate: EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EasyDelegate
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Delegate and deferred callers for C++11.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceEasyDelegate.html">EasyDelegate</a></li><li class="navelem"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classEasyDelegate_1_1DeferredStaticCaller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A deferred caller type for static methods.  
 <a href="classEasyDelegate_1_1DeferredStaticCaller.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="deferredcallers_8hpp_source.html">deferredcallers.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEasyDelegate_1_1DeferredStaticCaller.png" usemap="#EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt;_map" alt=""/>
  <map id="EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt;_map" name="EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt;_map">
<area href="classEasyDelegate_1_1ITypedDeferredCaller.html" title="A less generic deferred caller type that retains return type information. Use this if you don&#39;t care ..." alt="EasyDelegate::ITypedDeferredCaller&lt; returnType &gt;" shape="rect" coords="0,56,370,80"/>
<area href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla..." alt="EasyDelegate::IDeferredCaller" shape="rect" coords="0,0,370,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afa605942a91eb10ce3db757dabcb6f1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa605942a91eb10ce3db757dabcb6f1a"></a>
typedef returnType(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#afa605942a91eb10ce3db757dabcb6f1a">StaticDelegateMethodPointer</a>) (parameters...)</td></tr>
<tr class="memdesc:afa605942a91eb10ce3db757dabcb6f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper typedef referring to a static function pointer. <br /></td></tr>
<tr class="separator:afa605942a91eb10ce3db757dabcb6f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa50ec02742c651e31ecbd1f69e648bdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#aa50ec02742c651e31ecbd1f69e648bdf">DeferredStaticCaller</a> (const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#afa605942a91eb10ce3db757dabcb6f1a">StaticDelegateMethodPointer</a> methodPointer, parameters...params)</td></tr>
<tr class="memdesc:aa50ec02742c651e31ecbd1f69e648bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor accepting a pointer to a static method.  <a href="#aa50ec02742c651e31ecbd1f69e648bdf">More...</a><br /></td></tr>
<tr class="separator:aa50ec02742c651e31ecbd1f69e648bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab11b98fd8b4815cfee6ec00916786db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> returnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#aab11b98fd8b4815cfee6ec00916786db">dispatch</a> (void) const </td></tr>
<tr class="memdesc:aab11b98fd8b4815cfee6ec00916786db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>.  <a href="#aab11b98fd8b4815cfee6ec00916786db">More...</a><br /></td></tr>
<tr class="separator:aab11b98fd8b4815cfee6ec00916786db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356022c08432e9d39541ec903e4858f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#a356022c08432e9d39541ec903e4858f8">genericDispatch</a> (void) const </td></tr>
<tr class="memdesc:a356022c08432e9d39541ec903e4858f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>, ignoring the return value.  <a href="#a356022c08432e9d39541ec903e4858f8">More...</a><br /></td></tr>
<tr class="separator:a356022c08432e9d39541ec903e4858f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd01c8e64317d3c2914796c15659fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#a6bd01c8e64317d3c2914796c15659fb6">callsMethod</a> (const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#afa605942a91eb10ce3db757dabcb6f1a">StaticDelegateMethodPointer</a> methodPointer) const noexcept</td></tr>
<tr class="memdesc:a6bd01c8e64317d3c2914796c15659fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given static method address.  <a href="#a6bd01c8e64317d3c2914796c15659fb6">More...</a><br /></td></tr>
<tr class="separator:a6bd01c8e64317d3c2914796c15659fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0705894437f9cb113fcef8b08f624"><td class="memTemplParams" colspan="2">template&lt;typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:ae9e0705894437f9cb113fcef8b08f624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#ae9e0705894437f9cb113fcef8b08f624">callsMethod</a> (const <a class="el" href="namespaceEasyDelegate.html#a5bdc0a7cea0e9ab625f76217b818e049">StaticMethodPointer</a>&lt; otherReturn, otherParams...&gt; methodPointer) const noexcept</td></tr>
<tr class="memdesc:ae9e0705894437f9cb113fcef8b08f624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given static method address of a differing signature.  <a href="#ae9e0705894437f9cb113fcef8b08f624">More...</a><br /></td></tr>
<tr class="separator:ae9e0705894437f9cb113fcef8b08f624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5d5731c7e5783a91a12f5823233f9b"><td class="memTemplParams" colspan="2">template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:aaf5d5731c7e5783a91a12f5823233f9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#aaf5d5731c7e5783a91a12f5823233f9b">callsMethod</a> (const <a class="el" href="namespaceEasyDelegate.html#a4c8975b2bcb650f86a61d94194d1c523">MemberMethodPointer</a>&lt; otherClass, otherReturn, otherParams...&gt; methodPointer) const noexcept</td></tr>
<tr class="memdesc:aaf5d5731c7e5783a91a12f5823233f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given class member method address.  <a href="#aaf5d5731c7e5783a91a12f5823233f9b">More...</a><br /></td></tr>
<tr class="separator:aaf5d5731c7e5783a91a12f5823233f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab95470aeb57cb0b04b0495dd14c710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#abab95470aeb57cb0b04b0495dd14c710">hasSameMethodAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; returnType, parameters...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:abab95470aeb57cb0b04b0495dd14c710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same method as the specified <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>.  <a href="#abab95470aeb57cb0b04b0495dd14c710">More...</a><br /></td></tr>
<tr class="separator:abab95470aeb57cb0b04b0495dd14c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2613ad3c7ce84254bbfa30793ac469f2"><td class="memTemplParams" colspan="2">template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a2613ad3c7ce84254bbfa30793ac469f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#a2613ad3c7ce84254bbfa30793ac469f2">hasSameMethodAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; otherClass, otherReturn, otherParams...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:a2613ad3c7ce84254bbfa30793ac469f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same method as the specified <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>.  <a href="#a2613ad3c7ce84254bbfa30793ac469f2">More...</a><br /></td></tr>
<tr class="separator:a2613ad3c7ce84254bbfa30793ac469f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175673829bc1e63f44aeb3390ef05fe8"><td class="memTemplParams" colspan="2">template&lt;typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a175673829bc1e63f44aeb3390ef05fe8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#a175673829bc1e63f44aeb3390ef05fe8">hasSameMethodAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; otherReturn, otherParams...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:a175673829bc1e63f44aeb3390ef05fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same of the given <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> of a differing signature.  <a href="#a175673829bc1e63f44aeb3390ef05fe8">More...</a><br /></td></tr>
<tr class="separator:a175673829bc1e63f44aeb3390ef05fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e20c2a53191e93f44a832df8528e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#a00e20c2a53191e93f44a832df8528e7d">hasThisPointer</a> (const void *thisPointer) const noexcept</td></tr>
<tr class="memdesc:a00e20c2a53191e93f44a832df8528e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls against the given this pointer.  <a href="#a00e20c2a53191e93f44a832df8528e7d">More...</a><br /></td></tr>
<tr class="separator:a00e20c2a53191e93f44a832df8528e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921a697c2849e535d2de1d6c6ac73e55"><td class="memTemplParams" colspan="2">template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a921a697c2849e535d2de1d6c6ac73e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#a921a697c2849e535d2de1d6c6ac73e55">hasSameThisPointerAs</a> (const <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html">IDeferredCaller</a> *other) const noexcept</td></tr>
<tr class="memdesc:a921a697c2849e535d2de1d6c6ac73e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> shares the same this pointer as the given <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla...">IDeferredCaller</a>.  <a href="#a921a697c2849e535d2de1d6c6ac73e55">More...</a><br /></td></tr>
<tr class="separator:a921a697c2849e535d2de1d6c6ac73e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename returnType, typename... parameters&gt;<br />
class EasyDelegate::DeferredStaticCaller&lt; returnType, parameters &gt;</h3>

<p>A deferred caller type for static methods. </p>
<p>The <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> class works by storing the information required to make a call against a static method in its data structure when constructed. The parameters are stored in an std::tuple and are later unpacked when the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> is dispatched. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#_a2">example.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa50ec02742c651e31ecbd1f69e648bdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::<a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#afa605942a91eb10ce3db757dabcb6f1a">StaticDelegateMethodPointer</a>&#160;</td>
          <td class="paramname"><em>methodPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parameters...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor accepting a pointer to a static method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to the member function to be invoked. </td></tr>
    <tr><td class="paramname">params</td><td>The parameter list to use when later dispatching this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6bd01c8e64317d3c2914796c15659fb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::callsMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html#afa605942a91eb10ce3db757dabcb6f1a">StaticDelegateMethodPointer</a>&#160;</td>
          <td class="paramname"><em>methodPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given static method address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to a static method to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given method address. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9e0705894437f9cb113fcef8b08f624"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::callsMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEasyDelegate.html#a5bdc0a7cea0e9ab625f76217b818e049">StaticMethodPointer</a>&lt; otherReturn, otherParams...&gt;&#160;</td>
          <td class="paramname"><em>methodPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given static method address of a differing signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to a static method to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given method address. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because methods of different signatures should reside at their own addresses. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf5d5731c7e5783a91a12f5823233f9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::callsMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEasyDelegate.html#a4c8975b2bcb650f86a61d94194d1c523">MemberMethodPointer</a>&lt; otherClass, otherReturn, otherParams...&gt;&#160;</td>
          <td class="paramname"><em>methodPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given class member method address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to a class member method to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the given method address. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> types cannot call class member methods. </dd></dl>

</div>
</div>
<a class="anchor" id="aab11b98fd8b4815cfee6ec00916786db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> returnType <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </p>
<p>This is equivalent to the invoke() method on all other delegate types except the parameters were cached at creation. Said cached parameters will be passed in automatically upon calling this, so it is completely safe to store. </p><dl class="section return"><dt>Returns</dt><dd>Anything; it depends on the method signature defined in the template. </dd></dl>

<p>Implements <a class="el" href="classEasyDelegate_1_1ITypedDeferredCaller.html#a878c31a8ab74b572fdde1503cb182d11">EasyDelegate::ITypedDeferredCaller&lt; returnType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a356022c08432e9d39541ec903e4858f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> void <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::genericDispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>, ignoring the return value. </p>
<p>This behaves exactly as the dispatch method above except it does not care about the return of the called function. This method is also callable on the <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla...">IDeferredCaller</a> type, unlike the normal dispatch method. </p>

<p>Implements <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html#adb497c5783acdd6ae944b698d73cb9a2">EasyDelegate::IDeferredCaller</a>.</p>

</div>
</div>
<a class="anchor" id="abab95470aeb57cb0b04b0495dd14c710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::hasSameMethodAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; returnType, parameters...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same method as the specified <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same method as the given <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2613ad3c7ce84254bbfa30793ac469f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::hasSameMethodAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; otherClass, otherReturn, otherParams...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same method as the specified <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because a static method and a member method should never share the same address. </dd></dl>

</div>
</div>
<a class="anchor" id="a175673829bc1e63f44aeb3390ef05fe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::hasSameMethodAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; otherReturn, otherParams...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls the same of the given <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> of a differing signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to a <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not the two <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> instances call the same method. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because methods of different signatures should reside at their own addresses. </dd></dl>

</div>
</div>
<a class="anchor" id="a921a697c2849e535d2de1d6c6ac73e55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::hasSameThisPointerAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html">IDeferredCaller</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> shares the same this pointer as the given <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla...">IDeferredCaller</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to the <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla...">IDeferredCaller</a> to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> shares the same this pointer as the given <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla...">IDeferredCaller</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false for <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> types because they do not use a this pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a00e20c2a53191e93f44a832df8528e7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">EasyDelegate::DeferredStaticCaller</a>&lt; returnType, parameters &gt;::hasThisPointer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>thisPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls against the given this pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisPointer</td><td>A pointer referring to the object of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> calls a member function against the given this pointer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false for <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> types because they do not use a this pointer. </dd></dl>

<p>Reimplemented from <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html#aed3ec224abd59b56f9ebb3536a820ab8">EasyDelegate::IDeferredCaller</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="deferredcallers_8hpp_source.html">deferredcallers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 11 2015 03:35:33 for EasyDelegate by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
