<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>EasyDelegate: EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EasyDelegate
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Delegate and deferred callers for C++11.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceEasyDelegate.html">EasyDelegate</a></li><li class="navelem"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classEasyDelegate_1_1DeferredMemberCaller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A deferred caller type for class member methods.  
 <a href="classEasyDelegate_1_1DeferredMemberCaller.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="deferredcallers_8hpp_source.html">deferredcallers.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEasyDelegate_1_1DeferredMemberCaller.png" usemap="#EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt;_map" alt=""/>
  <map id="EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt;_map" name="EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt;_map">
<area href="classEasyDelegate_1_1ITypedDeferredCaller.html" title="A less generic deferred caller type that retains return type information. Use this if you don&#39;t care ..." alt="EasyDelegate::ITypedDeferredCaller&lt; returnType &gt;" shape="rect" coords="0,56,451,80"/>
<area href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla..." alt="EasyDelegate::IDeferredCaller" shape="rect" coords="0,0,451,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af80387f15096f62128d7f58293754009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af80387f15096f62128d7f58293754009"></a>
typedef <a class="el" href="namespaceEasyDelegate.html#a4c8975b2bcb650f86a61d94194d1c523">MemberMethodPointer</a>&lt; classType, returnType, parameters...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#af80387f15096f62128d7f58293754009">MemberDelegateMethodPointer</a></td></tr>
<tr class="memdesc:af80387f15096f62128d7f58293754009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper typedef referring to a class member method pointer. <br /></td></tr>
<tr class="separator:af80387f15096f62128d7f58293754009"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d1271e26235078ffdcb8240acff832d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a5d1271e26235078ffdcb8240acff832d">DeferredMemberCaller</a> (const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#af80387f15096f62128d7f58293754009">MemberDelegateMethodPointer</a> methodPointer, classType *thisPointer, parameters...params)</td></tr>
<tr class="memdesc:a5d1271e26235078ffdcb8240acff832d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor accepting a this pointer and a member method.  <a href="#a5d1271e26235078ffdcb8240acff832d">More...</a><br /></td></tr>
<tr class="separator:a5d1271e26235078ffdcb8240acff832d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101081e1022d38a036d1e684fb954dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> returnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a101081e1022d38a036d1e684fb954dd2">dispatch</a> (void) const </td></tr>
<tr class="memdesc:a101081e1022d38a036d1e684fb954dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>.  <a href="#a101081e1022d38a036d1e684fb954dd2">More...</a><br /></td></tr>
<tr class="separator:a101081e1022d38a036d1e684fb954dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7762937490a2dc209c4d06e4685cb8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a7762937490a2dc209c4d06e4685cb8d2">genericDispatch</a> (void) const </td></tr>
<tr class="memdesc:a7762937490a2dc209c4d06e4685cb8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>, ignoring the return value.  <a href="#a7762937490a2dc209c4d06e4685cb8d2">More...</a><br /></td></tr>
<tr class="separator:a7762937490a2dc209c4d06e4685cb8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e7141bc042548895fcea7a57c39cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a32e7141bc042548895fcea7a57c39cfe">callsMethod</a> (const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#af80387f15096f62128d7f58293754009">MemberDelegateMethodPointer</a> methodPointer) const noexcept</td></tr>
<tr class="memdesc:a32e7141bc042548895fcea7a57c39cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given class member method.  <a href="#a32e7141bc042548895fcea7a57c39cfe">More...</a><br /></td></tr>
<tr class="separator:a32e7141bc042548895fcea7a57c39cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe647ca421c50e60a2a9d768ea7fce8d"><td class="memTemplParams" colspan="2">template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:afe647ca421c50e60a2a9d768ea7fce8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#afe647ca421c50e60a2a9d768ea7fce8d">callsMethod</a> (const <a class="el" href="namespaceEasyDelegate.html#a4c8975b2bcb650f86a61d94194d1c523">MemberMethodPointer</a>&lt; otherClass, otherReturn, otherParams...&gt; methodPointer) const noexcept</td></tr>
<tr class="memdesc:afe647ca421c50e60a2a9d768ea7fce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given class member method of a differing signature.  <a href="#afe647ca421c50e60a2a9d768ea7fce8d">More...</a><br /></td></tr>
<tr class="separator:afe647ca421c50e60a2a9d768ea7fce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4635100a3b35054f7e385ec7af23b7"><td class="memTemplParams" colspan="2">template&lt;typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a9c4635100a3b35054f7e385ec7af23b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a9c4635100a3b35054f7e385ec7af23b7">callsMethod</a> (const <a class="el" href="namespaceEasyDelegate.html#a5bdc0a7cea0e9ab625f76217b818e049">StaticMethodPointer</a>&lt; otherReturn, otherParams...&gt; methodPointer) const noexcept</td></tr>
<tr class="memdesc:a9c4635100a3b35054f7e385ec7af23b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given static method.  <a href="#a9c4635100a3b35054f7e385ec7af23b7">More...</a><br /></td></tr>
<tr class="separator:a9c4635100a3b35054f7e385ec7af23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef849f24ec41d2ae38b165076c5e21c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#aeef849f24ec41d2ae38b165076c5e21c">hasSameMethodAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; classType, returnType, parameters...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:aeef849f24ec41d2ae38b165076c5e21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as another <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>.  <a href="#aeef849f24ec41d2ae38b165076c5e21c">More...</a><br /></td></tr>
<tr class="separator:aeef849f24ec41d2ae38b165076c5e21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89551e1eb38ce279e2d587cdf80623b9"><td class="memTemplParams" colspan="2">template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a89551e1eb38ce279e2d587cdf80623b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a89551e1eb38ce279e2d587cdf80623b9">hasSameMethodAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; otherClass, otherReturn, otherParams...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:a89551e1eb38ce279e2d587cdf80623b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as another <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> of a differing signature.  <a href="#a89551e1eb38ce279e2d587cdf80623b9">More...</a><br /></td></tr>
<tr class="separator:a89551e1eb38ce279e2d587cdf80623b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b979f2a819997798ee50a2c3267ce0d"><td class="memTemplParams" colspan="2">template&lt;typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a6b979f2a819997798ee50a2c3267ce0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a6b979f2a819997798ee50a2c3267ce0d">hasSameMethodAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; otherReturn, otherParams...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:a6b979f2a819997798ee50a2c3267ce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>.  <a href="#a6b979f2a819997798ee50a2c3267ce0d">More...</a><br /></td></tr>
<tr class="separator:a6b979f2a819997798ee50a2c3267ce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad69440dfbb8ff4c1a46704f455b382"><td class="memTemplParams" colspan="2">template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a6ad69440dfbb8ff4c1a46704f455b382"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a6ad69440dfbb8ff4c1a46704f455b382">hasSameThisPointerAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; otherClass, otherReturn, otherParams...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:a6ad69440dfbb8ff4c1a46704f455b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the same this pointer as another.  <a href="#a6ad69440dfbb8ff4c1a46704f455b382">More...</a><br /></td></tr>
<tr class="separator:a6ad69440dfbb8ff4c1a46704f455b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e16f84c9f3d3396a16a94307f1a0c0"><td class="memTemplParams" colspan="2">template&lt;typename otherReturn , typename... otherParams&gt; </td></tr>
<tr class="memitem:a13e16f84c9f3d3396a16a94307f1a0c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a13e16f84c9f3d3396a16a94307f1a0c0">hasSameThisPointerAs</a> (const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; otherReturn, otherParams...&gt; *other) const noexcept</td></tr>
<tr class="memdesc:a13e16f84c9f3d3396a16a94307f1a0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the same this pointer of the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>.  <a href="#a13e16f84c9f3d3396a16a94307f1a0c0">More...</a><br /></td></tr>
<tr class="separator:a13e16f84c9f3d3396a16a94307f1a0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35bbfbbd7e2ee6e6b396fb111dde4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#ae35bbfbbd7e2ee6e6b396fb111dde4e1">hasThisPointer</a> (const void *thisPointer) const noexcept</td></tr>
<tr class="memdesc:ae35bbfbbd7e2ee6e6b396fb111dde4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the given this pointer.  <a href="#ae35bbfbbd7e2ee6e6b396fb111dde4e1">More...</a><br /></td></tr>
<tr class="separator:ae35bbfbbd7e2ee6e6b396fb111dde4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a60ba74eadcd8852de830d663f86527e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60ba74eadcd8852de830d663f86527e4"></a>
classType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#a60ba74eadcd8852de830d663f86527e4">mThisPointer</a></td></tr>
<tr class="memdesc:a60ba74eadcd8852de830d663f86527e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the this object to invoke against. <br /></td></tr>
<tr class="separator:a60ba74eadcd8852de830d663f86527e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename classType, typename returnType, typename... parameters&gt;<br />
class EasyDelegate::DeferredMemberCaller&lt; classType, returnType, parameters &gt;</h3>

<p>A deferred caller type for class member methods. </p>
<p>The <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> class works by storing the information required to make a call against a class member method in its data structure when constructed. The parameters are stored in an std::tuple and are later unpacked when the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> is dispatched. </p><dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> is only valid while the given this pointer remains valid. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_8cpp-example.html#_a1">example.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5d1271e26235078ffdcb8240acff832d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::<a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#af80387f15096f62128d7f58293754009">MemberDelegateMethodPointer</a>&#160;</td>
          <td class="paramname"><em>methodPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">classType *&#160;</td>
          <td class="paramname"><em>thisPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parameters...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor accepting a this pointer and a member method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to the class member method to be invoked upon the this pointer. </td></tr>
    <tr><td class="paramname">thisPointer</td><td>A pointer to the object instance to be considered this during invocation. </td></tr>
    <tr><td class="paramname">params</td><td>Whatever parameters are required to later dispatch this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> invocation code has no way of knowing if the this pointer at any time has been deallocated. The <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> will cause undefined behavior and/or segfault upon invocation in that case. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a32e7141bc042548895fcea7a57c39cfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::callsMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html#af80387f15096f62128d7f58293754009">MemberDelegateMethodPointer</a>&#160;</td>
          <td class="paramname"><em>methodPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given class member method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to a class member method to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given method pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="afe647ca421c50e60a2a9d768ea7fce8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::callsMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEasyDelegate.html#a4c8975b2bcb650f86a61d94194d1c523">MemberMethodPointer</a>&lt; otherClass, otherReturn, otherParams...&gt;&#160;</td>
          <td class="paramname"><em>methodPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given class member method of a differing signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to a class member method to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given method pointer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because methods of differing signatures should reside at different addresses. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4635100a3b35054f7e385ec7af23b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::callsMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEasyDelegate.html#a5bdc0a7cea0e9ab625f76217b818e049">StaticMethodPointer</a>&lt; otherReturn, otherParams...&gt;&#160;</td>
          <td class="paramname"><em>methodPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given static method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">methodPointer</td><td>A pointer to a static method to be checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the given static method pointer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> types cannot call static methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a101081e1022d38a036d1e684fb954dd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> returnType <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>. </p>
<p>This is equivalent to the invoke() method on all other delegate types except the parameters were cached at creation. Said cached parameters will be passed in automatically upon calling this, so it is completely safe to store. </p><dl class="section return"><dt>Returns</dt><dd>Anything; it depends on the function signature defined in the template. </dd></dl>

<p>Implements <a class="el" href="classEasyDelegate_1_1ITypedDeferredCaller.html#a878c31a8ab74b572fdde1503cb182d11">EasyDelegate::ITypedDeferredCaller&lt; returnType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7762937490a2dc209c4d06e4685cb8d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> void <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::genericDispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>, ignoring the return value. </p>
<p>This behaves exactly as the dispatch method above except it does not care about the return of the called function. This method is also callable on the <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html" title="The most generic of the deferred caller types. All deferred callers eventually trace back to this cla...">IDeferredCaller</a> type, unlike the normal dispatch method. </p>

<p>Implements <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html#adb497c5783acdd6ae944b698d73cb9a2">EasyDelegate::IDeferredCaller</a>.</p>

</div>
</div>
<a class="anchor" id="aeef849f24ec41d2ae38b165076c5e21c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::hasSameMethodAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; classType, returnType, parameters...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as another <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as the other <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a89551e1eb38ce279e2d587cdf80623b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::hasSameMethodAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; otherClass, otherReturn, otherParams...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as another <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> of a differing signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to the <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as the other <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> of differing signature. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because methods of differing signatures should reside at different addresses. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b979f2a819997798ee50a2c3267ce0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::hasSameMethodAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; otherReturn, otherParams...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A pointer to the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls the same method as the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> types cannot call static methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ad69440dfbb8ff4c1a46704f455b382"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherClass , typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::hasSameThisPointerAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">DeferredMemberCaller</a>&lt; otherClass, otherReturn, otherParams...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the same this pointer as another. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the same this pointer of the other. </dd></dl>

</div>
</div>
<a class="anchor" id="a13e16f84c9f3d3396a16a94307f1a0c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<div class="memtemplate">
template&lt;typename otherReturn , typename... otherParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::hasSameThisPointerAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html">DeferredStaticCaller</a>&lt; otherReturn, otherParams...&gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the same this pointer of the <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the same this pointer of the other. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always returns false because <a class="el" href="classEasyDelegate_1_1DeferredStaticCaller.html" title="A deferred caller type for static methods. ">DeferredStaticCaller</a> types do not use a this pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae35bbfbbd7e2ee6e6b396fb111dde4e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename classType, typename returnType, typename... parameters&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="easydelegate_8hpp.html#a072acc29a763afc4c801a917b1c7f350">EASYDELEGATE_INLINE</a> bool <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html">EasyDelegate::DeferredMemberCaller</a>&lt; classType, returnType, parameters &gt;::hasThisPointer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>thisPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls against the given this pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisPointer</td><td>A pointer referring to the object of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing whether or not this <a class="el" href="classEasyDelegate_1_1DeferredMemberCaller.html" title="A deferred caller type for class member methods. ">DeferredMemberCaller</a> calls a class member method against the given this pointer. </dd></dl>

<p>Reimplemented from <a class="el" href="classEasyDelegate_1_1IDeferredCaller.html#aed3ec224abd59b56f9ebb3536a820ab8">EasyDelegate::IDeferredCaller</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="deferredcallers_8hpp_source.html">deferredcallers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 11 2015 03:35:33 for EasyDelegate by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
